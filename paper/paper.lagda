\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\ifpdf
  \usepackage{hyperref}
\fi
\usepackage{float}
\usepackage{proof}
%if False
\begin{code}
module paper where
\end{code}
%endif

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


%Conference
\acmConference[SBLP'19]{Brazilian Symposium on Programming Languages}{September 2019}{Salvador, Bahia Brazil}
\acmYear{2019}
\copyrightyear{2019}


%include lhs2TeX.fmt
%include lhs2TeX.sty
%include polycode.fmt

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}
%subst keyword a = "\mathkw{" a "}"
%subst conid a = "\V{" a "}"
%subst varid a = "\V{" a "}"
%subst numeral a = "\Con{" a "}"

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\Con}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}

%subst comment a = "\orange{\texttt{--" a "}}"

\begin{document}


\title{Towards Typed Semantics for Parsing Expression Grammars}

\author{Rodrigo Ribeiro}
\affiliation{
  \institution{Universidade Federal de Ouro Preto}
  \city{Ouro Preto}
  \state{Minas Gerais --- Brazil}
}
\email{rodrigo.ribeiro@@ufop.edu.br}

\author{Leonardo V. S. Reis}
\affiliation{%
\institution{Universidade Federal de Juiz de Fora}
\city{Juiz de Fora}
\state{Minas Gerais --- Brazil}
}
\email{lvsreis@@ice.ufjf.br}

\author{Samuel Feitosa}
\affiliation{%
  \institution{Universidade Federal de Pelotas}
  \city{Pelotas}
  \state{Rio Grande do Sul --- Brazil}
}
\email{samuel.feitosa@@inf.ufpel.br}

\author{Elton M. Cardoso}
\affiliation{
\institution{Universidade Federal de Ouro Preto}
\city{João Monlevade}
\state{Minas Gerais --- Brazil}
}

\email{elton.cardoso@@ufop.edu.br}

\begin{abstract}
We describe the formalization of a type system for parsing
expression grammars (PEG) which is equivalent to Ford's original
fixpoint-based definition of well-formed PEGs. We use our type
system definition to implement a functional big-step semantics
for typed PEGs using Agda programming language.
\end{abstract}
%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}

% We no longer use \terms command
%\terms{Theory}

\keywords{Parsing, Parsing Expression Grammars, Type systems}

\maketitle

%format . = "."
%format Set = "\D{Set}"
%format Set0 = Set "_{\D{0}}"
%format Set1 = Set "_{\D{1}}"
%format List = "\D{List}"
%format [] = "\Con{\lbrack\:\rbrack}"
%format , = "\red{,}\,"
%format Nat = "\D{\mathbb{N}}"
%format zero = "\Con{zero}"
%format succ = "\Con{suc}"
%format id = "\F{id}"
%format o = "\F{\circ}"
%format Vec = "\D{Vec}"
%format :: = "\Con{::}"
%format _::_ = "\Con{\_::\_}"

\section{Introduction}\label{sec:intro}

Parsing is one of the most studied problems in computer science.
It involves the process of checking if a string of symbols conforms to
a given set of rules. Usually, parsing is preceded by the
specification of rules in a formalism (e.g. a grammar) and, also, either the
construction of data that makes evident which rules have been used to
conclude that the string of symbols can be obtained from it or, otherwise,
an indication of an error that represents the
fact that the string of symbols cannot be generated.

Parsing Expression Grammars (PEGs) are a recognition-based formalism to
define languages~\cite{Ford2004} which, instead of specifying how to
generate a string, define how to parse or check whether a string is in
the language being defined. Similarly to context-free grammars (CFGs),
formally a PEG is a 4-tuple $(V_N, V_T, R, e_S)$ where $V_N$ and $V_T$ are
as in CFGs, $R$ is a function which maps a nonterminal
from $V_N$ to a {\it parsing expression} and $e_S$ is the initial parsing
expression. A parsing expression is very
similar to the right-hand side of a CFG in the extended Backus-Naur
form with the addition of new operators, the not-predicate (!) and
the prioritized choice (/). A fundamental difference between PEG
and CFGs is the choice operator, which impose priority between alternatives.
It means that $\beta$ in an expression $\alpha / \beta$ is tested only
in case of a failure on $\alpha$. The not-predicate operator checks
if the string matches some syntax without consuming the input.

A key aspect of Ford's PEG definition is the concept of \emph{completeness},
which states that a PEG either succeeds or fails in processing every input
string. Intuitively, the notion of completeness ensures the termination of
PEGs. However, determine whether a PEG is complete is an undecidable
problem~\cite{Ford2004}. In order to provide a criterion which is good enough
for most PEGs definitions, Ford introduces the \emph{well-formedness} predicate
and shows that if a PEG is well-formed then it is complete. The well-formedness
test proposed by Ford is computed as a fixpoint to ensure that every expression
on a PEG is well-formed.
In our view, this notion could be much more simple
and predictable for a user of PEG if it was expressed as a type system.

As an example of our point, let be the parsing expression $a (!b / c)^*$.
Based on the fixpoint well-formed definition, that expression is well-formed.
It is because Ford states that a sequence, $e_1 e_2$, is well-formed if the
expression $e_1$ is well-formed and, if expression $e_1$ can be nullable
implies that expression $e_2$ is well-formed.
It is clear that the terminal expression $a$ is not nullable and is well-formed,
so the conclusion follows.
However, a grammar including that expression is not well-formed.
It happens because Ford includes an additional constraint requiring that all
subexpressions in a grammar must be well-formed and the subexpression $(!b / c)^*$
is not, turning a grammar containing that expression ill-formed.

% Examples of ill-formed PEG.
% pegjs.org catch all then!
% A = 'a' (!'b' / 'c')*
% B = ('a' / 'b')* B
% C = ('b' / C)*

% B = ('a' / 'b')* C
% C = ('b' / B)*

We argue this two-step definition may confuse the user.
To overcome that, in this work, we define a type system for PEGs which is intuitive and could
be used as an alternative to Ford's well-formedness predicate to ensure
completeness.
More specifically, our contributions are:
\begin{itemize}
  \item A formalization of a type system for PEGs which can be used as an
        alternative to Ford's fixpoint based well-formedness definition.
  \item We show that well-typed PEGs are \emph{complete}, i.e., they
        terminate for every input string, by proving that well-typed
        parsing expressions are well-formed.
  \item We use our type system as the basis to define an interpreter
        for an intrinsically typed encoding of PEGs, i.e, we define a
        functional big-step semantics for PEGs~\cite{Owens2016}.
        We implement the interpreter using Agda programming language.
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{sec:background}
reviews the syntax, semantics, well-formedness of PEGs and
presents a brief introduction to Agda. In Section~\ref{sec:typing} we
describe the type system for PEGs and its relation with the original
well-formedness predicate proposed by Ford~\cite{Ford2004}.
Section~\ref{sec:interpreter} describes PEGs intrinsically typed syntax,
and its interpreter. Limitations of our approach are discussed
in Section~\ref{sec:discussion}. Related work is discussed on
Section~\ref{sec:related} and Section~\ref{sec:conclusion} concludes.

All the source code in this article has been formalized in Agda
version 2.6.0 using Standard Library 1.0, but
we do not present every detail. Proofs of some properties result in
functions with a long pattern matching structure, that would distract
the reader from understanding the high-level structure of the
formalization. In such situations we give just proof sketches and point
out where all details can be found in the source code.

All source code produced, including the \LaTeX~ source of this
article, are avaliable on-line~\cite{peg-rep}.

\section{Background}\label{sec:background}

\paragraph{An Overview of PEGs}%\label{sec:pegs}

PEGs are a recognition-based formalism which describes syntax which
can be parsed using top-down parsing techniques. Formally, a PEG is
a 4-uple $G = (V,\Sigma,R,e_S)$, where $V$ is a finite set of variables,
$\Sigma$ is the alphabet, $R$ is the finite set of rules, and $e_s$ is
the start expression. Each rule $r \in R$ is a pair $(A,e)$, usually written
$A \leftarrow e$, where $A \in V$ and $e$ is a parsing expression. We let
meta-variable $a$ denote an arbitrary alphabet symbol, $A$ a variable
and $e$ an parsing expression. Following common practice, all meta-variables
can appear primed or subscripted. The syntax of parsing expression is defined
by the following context-free grammar.

  \[
     \begin{array}{lcl}
        e & \to  & \epsilon \,\mid\, a \,\mid\, A\,\mid\,e_1\:e_2\,
                   \mid\,e_1\,/\,e_2\,\mid\,e^\star\,\mid\,!\,e\\
     \end{array}
  \]

The semantics of parsing expressions is given using an inductively defined
judgement which relates pairs formed by a parsing expression and an input string
to pairs formed by the consumed prefix and the remaining string. We let
notation $(e,s) \Rightarrow_G (s_p,s_r)$ denote that parsing expression $e$
consumes the prefix $s_p$ from the input string $s$ leaving the suffix $s_r$.
We let $(e,s) \Rightarrow_G \bot$ denote the fact that $s$ cannot be parsed by
$e$ and meta-variable $r$ represents a parsing result, i.e., either $r$ is a
pair $(s_p,s_r)$ or $\bot$. We say that an expression $e$ fails if its execution
over an input produces $\bot$; otherwise it succeeds. The semantics is defined in
Figure~\ref{fig:pegsemantics}.
\begin{figure*}
   \[
      \begin{array}{cccc}
         \infer[_{\{Eps\}}]{(\epsilon,s)\Rightarrow_G (\epsilon,s)}{} &
         \infer[_{\{ChrS\}}]{(a,as_r) \Rightarrow_G (a,s_r)}{}  &
         \infer[_{\{ChrF\}}]{(a,bs_r) \Rightarrow_G \bot}{a \neq b} &
         \infer[_{\{Var\}}]{(A,s) \Rightarrow_G r}
                           {A \leftarrow e \in R & (e,s) \Rightarrow_G r} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{S1}\}}]{(e_1\,e_2,s_{p1}s_{p2}s_r) \Rightarrow_G (s_{p1}s_{p2}, s_r)}
                                 {(e_1,s_{p1}s_{p2}s_r) \Rightarrow_G (s_{p1},s_{p2}s_r) &
                                 (e_2,s_{p2}s_r)\Rightarrow_G (s_{p2},s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{F2}\}}]{(e_1\,e_2,s_ps_r) \Rightarrow_G \bot}
                                 { (e_1,s_ps_r) \Rightarrow_G (s_p,s_r) &
                                    (e_2,s_r) \Rightarrow_G \bot}} \\ \\
         \infer[_{\{Cat_{F1}\}}]{(e_1\,e_2,s)\Rightarrow_G \bot}{(e_1,s) \Rightarrow_G \bot} &
         \infer[_{\{Alt_{S1}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Rightarrow_G (s_p,s_r)}
                                {(e_1,s_p\,s_r)\Rightarrow_G (s_p,s_r)} &
         \multicolumn{2}{c}{
            \infer[_{\{Alt_{S2}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Rightarrow_G r}
                                  {(e_1,s_p\,s_r)\Rightarrow_G \bot &
                                   (e_2,s_p\,s_r)\Rightarrow_G r}
         } \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Star_{rec}\}}]{(e^\star,s_{p1}s_{p2}s_r) \Rightarrow_G (s_{p1}s_{p2},s_r)}
                                 {(e,s_{p1}s_{p2}s_r) \Rightarrow_G (s_{p1},s_{p2}s_r) &
                                  (e^\star, s_{p2}s_r) \Rightarrow_G (s_{p2},s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Star_{end}\}}]{(e^\star,s) \Rightarrow_G (\epsilon,s)}
                                    {(e,s) \Rightarrow_G \bot}} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Not_F\}}]{(!\,e,s_p\,s_r) \Rightarrow_G \bot}
                               {(e,s_p\,s_r) \Rightarrow_G (s_p,s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Not_S\}}]{(!\,e,s) \Rightarrow_G (\epsilon,s)}
                               {(e,s) \Rightarrow_G \bot}
         }
      \end{array}
   \]
   \centering
   \caption{Parsing expressions operational semantics.}
   \label{fig:pegsemantics}
\end{figure*}

We comment on some rules of the semantics. Rule $_{Eps}$ specifies that
expression $\epsilon$ do not fail on any input $s$ by leaving it unchanged.
Rule $_{ChrS}$ specifies that an expression $a$ consumes the first character
when the input string starts with an `a' and rule $_{ChrF}$ shows that it
fails when the input starts with a different symbol. Variable rule $_{Var}$
parses the input using the expression associated with the variable in the
grammar $G$. When parsing a sequence expression, $e_1\:e_2$, the result is formed
by $e_1$ and $e_2$ parsed prefixes and the remaining input is given by $e_2$.
Rules $_{Cat_{F1}}$ and $_{Cat_{F2}}$ says that if $e_1$ or $e_2$ fails, then
the whole expression fails. The rules for choice impose that we only try
expression $e_2$ in $e_1 / e_2$ when $e_1$ fails. Parsing a star expression
$e^\star$ consists in repeatedly execute $e$ on the input string. When $e$ fails,
$e^\star$ succeeds without consuming any symbol of the input string. Finally,
rules for the not predicate expression, $!\,e$, specifies that whenever the
expression $e$ succeeds on input $s$, $!\,e$ fail; and when $e$ fails on $s$
we have that $!\,e$ succeeds without consuming any input.

Following~\cite{Ford2004}, we let notation $e \rightharpoonup 0$ denote
that parsing expression $e$ can succeed without consuming any input and
$e \rightharpoonup f$ denote that $e$ fails on some input.
We say that a PEG is complete if it succeeds or fails on any string.
Unfortunately, the problem of determining if an arbitrary PEG is complete
is undecidable~\cite{Ford2004}. However, Ford gives an well-formedness predicate
on parsing expressions which states that an expression is well-formed if
it does not contain neither direct or indirect left-recursion or a
sub-expression of the form $e^\star$ in which $e \rightharpoonup 0$.
Finally, a PEG is considered well-formed if all
of its sub-expressions are well-formed. Thus, the problem of determining if
a PEG is well-formed is done by a fixed-point computation on the set of all
sub-expressions of a grammar. The definition of well-formedness of parsing
expression is defined by the judgment $G \vdash e$, where $G$ is a PEG and
$e$ a parsing expression of $G$.
Its definition is presented on Figure~\ref{fig:wellformedness}.
All the rules are self-explained and only rule $_{CatW}$ deserves some comments. 
It specifies that a sequence, $e_1 e_2$, is well-formed when $e_1$ is well-formed and,
in the case it may succeed without consuming input symbols, the parsing expression $e_2$ also must be well-formed.
That rule allows to identify recursive nonterminals as well-formed such in the parsing expression $A \leftarrow a A$.
However, some parsing expression that may loop are identified as well-formed.
The parsing expression $a(!b / c)^*$ is a such example. 
To overcome that, Ford includes an additional constraint requiring all sub-expressions in a PEG must be well-formed. 

%\begin{figure}
%   \[
%      \begin{array}{cccc}
%         \infer[_{\{EpsW\}}]{G \vdash \epsilon}{} &
%         \infer[_{\{ChrW\}}]{G \vdash a}{a \in \Sigma} &
%         \multicolumn{2}{c}{\infer[_{\{AltW\}}]{G \vdash e_1 / e_2}{G\vdash e_1 & G \vdash e_2}} \\ \\
%         \multicolumn{2}{c}{
%         \infer[_{\{VarW\}}]{G \vdash A}{A \in V & A \leftarrow e \in R & G \vdash e}
%         } &
%         \multicolumn{2}{c}{
%            \infer[_{\{CatW\}}]{G\vdash e_1\,e_2}{G\vdash e_1 & e_1 \rightharpoonup 0 \text{ implies } G\vdash %e_2}
%         } \\ \\
%         \multicolumn{2}{c}{\infer[_{\{NotW\}}]{G\vdash !\,e}{G \vdash e}} &
%         \multicolumn{2}{c}{
%            \infer[_{\{StarW\}}]{G\vdash e^\star}{G \vdash e & e \not\rightharpoonup 0}
%         }
%      \end{array}
%   \]
%   \centering
%   \caption{Parsing expression well-formedness judgement.}
%   \label{fig:wellformedness}
%\end{figure}


\begin{figure}
\[
\begin{array}{ccc}
\multicolumn{3}{c}{
\infer[_{\{EpsW\}}]{G \vdash \epsilon}{} \;\;\;\;
\infer[_{\{ChrW\}}]{G \vdash a}{a \in \Sigma} \;\;\;\;
\infer[_{\{NotW\}}]{G\vdash !\,e}{G \vdash e}
} \\ \\
\multicolumn{3}{c}{
\infer[_{\{VarW\}}]{G \vdash A}{A \in V & A \leftarrow e \in R & G \vdash e}
\;\;\;\;
\infer[_{\{StarW\}}]{G\vdash e^\star}{G \vdash e & e \not\rightharpoonup 0}
} \\ \\
\multicolumn{3}{c}{
\infer[_{\{CatW\}}]{G\vdash e_1\,e_2}{G\vdash e_1 & e_1 \rightharpoonup 0 \text{ implies } G\vdash e_2}
\;\;\;\;
\infer[_{\{AltW\}}]{G \vdash e_1 / e_2}{G\vdash e_1 & G \vdash e_2}
}
\end{array}
\]
\centering
\caption{Parsing expression well-formedness judgement.}
\label{fig:wellformedness}
\end{figure}



\paragraph{An Overview of Agda}%\label{sec:agda}

%format String = "\D{String}"
%format Bool = "\D{Bool}"
%format forall = "\D{\forall}"
Agda is a dependently-typed functional programming language based on
Martin-L\"of intuitionistic type theory~\cite{Lof98}.  Function types
and an infinite hierarchy of types of types, |Set l|, where |l| is a
natural number, are built-in. Everything else is a user-defined
type. The type |Set|, also known as |Set0|, is the type of all
``small'' types, such as |Bool|, |String| and |List Bool|.  The type
|Set1| is the type of |Set| and ``others like it'', such as |Set ->
Bool|, |String -> Set|, and |Set -> Set|. We have that |Set l| is an
element of the type |Set (l+1)|, for every $l \geq 0$. This
stratification of types is used to keep Agda consistent as a logical
theory~\cite{Sorensen2006}.

An ordinary (non-dependent) function type is written |A -> B| and a
dependent one is written |(x : A) -> B|, where type |B| depends on
|x|, or |forall (x : A) -> B|. Agda allows the definition of \emph{implicit
parameters}, i.e.  parameters whose values can be infered from the
context, by surrounding them in curly braces: |forall {x : A} -> B|. To
avoid clutter, we'll omit implicit arguments from the source code
presentation. The reader can safely assume that every free variable in
a type is an implicity parameter.

As an example of Agda code, consider the following data type of
length-indexed lists, also known as vectors.

\begin{code}
  data Nat : Set where
    zero : Nat
    succ : Nat -> Nat

  data Vec (A : Set) : Nat -> Set where
    []  : Vec A zero
    _::_ : forall {n} -> A -> Vec A n -> Vec A (succ n)
\end{code}
%format head = "\F{head}"
Constructor |[]| builds empty vectors. The cons-operator (|_::_|)
inserts a new element in front of a vector of $n$ elements (of type
|Vec A n|) and returns a value of type |Vec A (succ n)|. The
|Vec| datatype is an example of a dependent type, i.e. a type
that uses a value (that denotes its length). The usefulness of
dependent types can be illustrated with the definition of a safe list
head function: |head| can be defined to accept only non-empty
vectors, i.e.~values of type |Vec A (succ n)|.
\begin{spec}
  head : Vec A (succ n) -> A
  head (x :: xs) = x
\end{spec}
In |head|'s definition, constructor |[]| is not used. The
Agda type-checker can figure out, from |head|'s parameter type,
that argument |[]| to |head| is not type-correct.

%format _==_ = "\D{\_ \equiv \_}"
%format == = "\D{\equiv}"
%format refl = "\Con{refl}"
%format proj₁ = "\F{\pi_1}"
%format proj₂ = "\F{\pi_2}"
%format Fin   = "\D{Fin}"
%format lookup = "\F{lookup}"


Another useful data type is finite type, which is defined in
Agda's standard library as:

\begin{code}
  data Fin : Nat -> Set where
    zero : forall {n} -> Fin (succ n)
    succ : forall {n} -> Fin n -> Fin (succ n)
\end{code}
Note that Agda supports the overloading of data type constructor names.
Constructor |zero| can refer to type |Nat| or |Fin|, depending on the
context where the name is used. Type |Fin n| has exactly |n| inhabitants
(elements), i.e. it is isomorphic to the set $\{0,...,n - 1\}$.
An application of such type is to define a safe vector
lookup function, which avoids the access of invalid positions.
\begin{code}
  lookup : forall {A n} -> Fin n -> Vec A n -> A
  lookup zero (x :: _) = x
  lookup (succ idx) (_ :: xs) = lookup idx xs
\end{code}
Thanks to the propositions-as-types principle\footnote{Also known as
  Curry-Howard ``isomorphism''~\cite{Sorensen2006}.} we can interpret
types as logical formulas and terms as proofs. An example is the
representation of equality as the following Agda type:

\begin{code}
  data _==_ {l}{A : Set l}(x : A) : A -> Set where
    refl : x == x
\end{code}

%format not = "\F{\neg}"
%format Dec = "\D{Dec}"
%format yes = "\Con{yes}"
%format no  = "\Con{no}"
%format Even = "\Con{Even}"
%format Odd = "\Con{Odd}"
%format Parity = "\D{Parity}"
%format parity = "\F{parity}"
%format natToBin = "\F{natToBin}"
%format false = "\Con{false}"
%format true = "\Con{true}"
%format + = "\F{+}"
%format ++ = "\F{++}"
%format Bot = "\D{\bot}"
%format All = "\D{All}"
This type is called propositional equality. It defines that there is
a unique evidence for equality, constructor |refl| (for reflexivity),
that asserts that the only value equal to |x| is itself. Given a predicate |P : A -> Set|
and a vector |xs|, the type |All P xs| is used to build proofs that |P| holds for all
elements in |xs| and it is defined as:
\begin{spec}
  data All (P : A -> Set) : Vec A n ->  Set where
     [] : All P []
     _::_ : forall {x xs} -> P x -> All P xs -> All P (x :: xs)
\end{spec}
The first constructor specifies that |All P| holds for the empty vector and
constructor |_::_| builds a proof of |All P (x :: xs)| from proofs of
|P x| and |All P xs|. Since this type has the same structure of vectors,
some functions on |Vec| have similar definitions for type |All|. As an example
used in our formalization, consider the function |lookup|, which extracts a
proof of |P| for the element at position |v :: Fin n| in a |Vec|:
\begin{spec}
   lookup : {xs : Vec A n} -> Fin n -> All P xs -> P x
   lookup zero (px :: _) = px
   lookup (succ idx) (_ :: pxs) = lookup idx pxs
\end{spec}


An important application of dependent types is to encode programming languages
syntax. The role of dependent types in this domain is to encode programs that
only allow well-typed and well-scoped terms~\cite{Benton2012}. Intuitively, we encode
the static semantics of the object language in the host language AST's
constructor, leaving the responsibility of checking type safety to the
host's language type checker. As an example, consider the following simple
expression language.
%format Expr = "\D{Expr}"
%format True = "\Con{True}"
%format False = "\Con{False}"
%format Num = "\Con{Num}"
%format _&_ = "\Con{\_\land\_}"
%format _+_ = "\Con{\_+\_}"
\begin{spec}
   data Expr : Set where
      True False : Expr
      Num : Nat -> Expr
      _&_ _+_ : Expr -> Expr -> Expr
\end{spec}
Using this data type\footnote{Agda supports the definition of mixfix operators.
We can use underscores to mark arguments positions.} we can construct expressions
that denote terms that should not be considered well-typed like
|(Num 1) + True|. Using this approach, we need to specify the static semantics
as another definition, which should consider all possible cases to avoid the
definition of ill-typed terms.

A better approach is to combine the static semantics and language syntax into
a single definition, as shown below.

%format Ty = "\D{Ty}"
%format Natt = "\Con{Nat}"
%format Booll = "\Con{Bool}"
\begin{spec}
   data Ty : Set where
      Natt Booll : Ty

   data Expr : Ty -> Set where
      True False : Expr Booll
      Num : Natt -> Expr Natt
      _&_ : Expr Booll -> Expr Booll -> Expr Booll
      _+_ : Expr Natt -> Expr Natt -> Expr Natt
\end{spec}

In this definition, the |Expr| type is indexed by a value of type |Ty| which
indicates the type of the expression being built. In this approach, Agda's
type system can enforce that only well-typed terms could be written. A definition
which uses the expression |(Num 1) + True| will be rejected by Agda's type
checker automatically.

%Dependently typed pattern matching is built by using the so-called
%|with| construct, that allows for matching intermediate
%values~\cite{McBride2004}. If the matched value has a dependent type,
%then its result can affect the form of other values. For example,
%consider the following code that defines a type for natural number
%parity. If the natural number is even, it can be represented as the
%sum of two equal natural numbers; if it is odd, it is equal to one
%plus the sum of two equal values. Pattern matching on a value of
%|Parity n| allows to discover if $n = j + j$ or $n = S (k + k)$,
%for some $j$ and $k$ in each branch of |with|.  Note that the
%value of $n$ is specialized accordingly, using information ``learned''
%by the type-checker.
%\begin{spec}
%data Parity : Nat -> Set where
%   Even : forall {n : Nat} -> Parity (n + n)
%   Odd  : forall {n : Nat} -> Parity (S (n + n))
%
%parity : (n : Nat) -> Parity n
%parity = -- definition omitted

%natToBin : Nat -> List Bool
%natToBin zero = []
%natToBin k with (parity k)
%   natToBin (j + j)     | Even = false :: natToBin j
%   natToBin (succ (j + j)) | Odd  = true  :: natToBin j
%\end{spec}

For further information about Agda, see~\cite{Norell2009,Stump16}.

\section{A Type System for PEGs}\label{sec:typing}

\paragraph{Type syntax} Our types are records formed by a boolean
value indicating that current parsing expression may succeed without
consuming anything and a set of variables that can appear as the first
symbol on the recognition branch from the current parsing expression.
%its respective first-set~\cite{Aho2006}.
The definition of this set of variables, named head-set, for a given parsing expression is
easily defined by recursion:
\[
   \begin{array}{lcl}
      head (\epsilon) & = & \emptyset \\
      head (a)        & = & \emptyset \\
      head (A)        & = & \{A\} \cup head(R(A)) \\
      head (e_1\,e_2) & = & \left\{
                                \begin{array}{ll}
                                   head(e_1) \cup head(e_2) & \text{if }e_1 \rightharpoonup 0\\
                                   head(e_1) & \text{otherwise}
                                \end{array}
                             \right. \\
      head(e_1\,/\,e_2) & = & head(e_1) \cup head(e_2) \\
      head(e^\star) & = & head(e) \\
      head(!\,e)    & = & head(e)
   \end{array}
\]
Following common practice, we let meta-variable $\tau$ denote an arbitrary type. Notations
$\tau.\textit{null}$ is true if the current
expression may succeed without consuming any symbol and $\tau.\textit{head}$ holds the head set of the
current expression. We use notation $\langle b , S \rangle$ to denote a
type $\tau$ formed by a boolean value $b$ and a set $S$. In the type system,
we use the following operations:

\[
   \begin{array}{lcl}
      b \Rightarrow S       & = & \text{if } b \text{ then } S \text{ else }\emptyset\\
      \tau_1 \otimes \tau_2 & = & \langle \tau_1.null \land \tau_2.null,
          \tau_1.head \cup (\tau_1.null \Rightarrow \tau_2.head) \rangle \\
      \tau_1 \oplus \tau_2  & = & \langle \tau_1.null \lor \tau_2.null, \tau_1.head \cup \tau_2.head\rangle\\
   \end{array}
\]

The first operation is a boolean test which returns the set $S$ whenever the condition is true.
The product operation ($\tau_1 \otimes \tau_2$) combines two types by taking the conjunction of their boolean flags and the
union of its respective head sets. The co-product operation ($\tau_1 \oplus \tau_2$) on types is similar to the
product but instead of using conjunction it takes the disjunction of their boolean fields.

\paragraph{Typing contexts} We use meta-variable $\Gamma$ to denote an arbitrary
typing context which consists of a sequence of pairs formed by a variable and
its corresponding type. We also use the following notations:
\[
   \begin{array}{l}
     \Gamma(A) = \{\tau \,\mid\, (A,\tau) \in \Gamma \} \\
   \end{array}
\]
We let notation $\bullet$ denote an empty typing context.

\paragraph{Type system definition} Our type system is defined as an inductive judgment
$\Gamma \vdash e : \tau$, where $\Gamma$ is a typing context, $e$ is a parsing expression
and $\tau$ is a type. We consider a PEG $G = (V,\Sigma,R,e_S)$ well typed, written $\Gamma \vdash G$,
if $\forall A. A \in V \to \exists \tau. \Gamma \vdash R(A) : \tau$.
\begin{figure}[H]
\[
  \begin{array}{ccc}
    \infer{\Gamma \vdash \epsilon : \langle true , \emptyset \rangle}{} &
    \infer{\Gamma \vdash a : \langle false , \emptyset\rangle} & \infer{\Gamma \vdash A : \tau}{\Gamma(A) = \tau & A \not\in \tau.head}\\ \\

    \multicolumn{2}{c}{\infer{\Gamma\vdash e_1\,/\,e_2 : \tau_1 \oplus \tau_2}{\Gamma \vdash e_1 : \tau_1 & \Gamma \vdash e_2 : \tau_2}} &

  \infer{\Gamma\vdash !\,e : \langle true , \tau.head \rangle}{\Gamma \vdash e : \tau}\\ \\

    \multicolumn{2}{c}{\infer{\Gamma\vdash e_1\,e_2 : \tau_1 \otimes \tau_2}{\Gamma \vdash e_1 : \tau_1 & \Gamma \vdash e_2 : \tau_2}} &
    \infer{\Gamma\vdash e^\star : \langle true, S \rangle}{\Gamma \vdash e : \langle false, S \rangle}
  \end{array}
\]
\centering
\caption{Type system definition.}
\label{fig:typesystem}
\end{figure}
The first rule of our type system specifies that parsing expression $\epsilon$ has type $\langle true, \emptyset \rangle$.
The rule of a single character expression says that its type is $\langle false, \emptyset\rangle$, since it does not succeed without
consuming a symbol and no variable can appear as the head of its recognition branch, i.e. its head set is $\emptyset$. The type of a prioritized
choice expression ($e_1/e_2$) has type $\tau_1 \oplus \tau_2$,
where $\Gamma \vdash e_1 : \tau_1$ and $\Gamma \vdash e_2 : \tau_2$. Type of a sequence expression is given by the product operation
on their sub-expressions types and the star operation is only well-typed if its underlying expression does not succeed without consuming
a symbol. A not-predicate parsing expression has always the type $\langle false, \tau.head \rangle$ whenever its subexpression is well-typed.
Finally, a variable is well-typed only if its type is in the context and itself does not belong to its head set.

\begin{Example}
  Consider the parsing expression $a(!b/c)^*$. As previously discussed, such expression is not well formed accordingly to Ford's
  fixpoint-based definition. Using our type system, the expression $!b/c$ is well-typed in the empty typing context, as shown by
  the next derivation.
  \[
    \infer{\bullet \vdash !b / c : \langle true , \emptyset \rangle}
          {
            \infer{\bullet \vdash !b \langle true , \emptyset \rangle}
                  {
                    \infer{\bullet \vdash b : \langle false , \emptyset \rangle}{}
                  }
            &
            \infer{\bullet \vdash c : \langle false , \emptyset \rangle}{}
          }
  \]
  Unfortunately, we cannot build a typing derivation for $(!b/c)^*$, because the rule for the star operator demands that its
  subexpression does not succeed without consuming any symbol and since $(!b / c) \rightharpoonup 0$, we can deduce that
  $(! b/c)^*$ is not well-typed.
\end{Example}

\noindent Our type system is sound and complete w.r.t. the head-set function and the relation $e \rightharpoonup 0$.

\begin{Lemma}\label{lemma1}
  Let $\Gamma \vdash e : \tau$. Then, we have that $\tau.null$ holds if, and only if, $e \rightharpoonup 0$.
\end{Lemma}
\begin{proof}
  Induction on the structure of $e$.
\end{proof}

\begin{Lemma}\label{lemma2}
Let $\Gamma \vdash e : \tau$. Then, we have that $\tau.head = head(e)$.
\end{Lemma}
\begin{proof}
  Induction on the structure of $e$.
\end{proof}

Recall Ford's well-formedness predicate for parsing expressions~\cite{Ford2004},
$G \vdash e$, presented in Figure~\ref{fig:wellformedness}.
The next theorem states that well-formedness of parsing expressions is equivalent to
well-typednes.

\begin{Theorem}
  Let $e$ be an parsing expression, $\Gamma$ a typing context and $\tau$ a type.
  Then $\Gamma \vdash e : \tau$ holds if, and only if, $G \vdash e$ holds.
\end{Theorem}
\begin{proof}
  Induction on the structure of $e$ using lemmas \ref{lemma1} and \ref{lemma2}.
\end{proof}


\section{PEG Typed Syntax and Interpreter}\label{sec:interpreter}

%format Char = "\D{Char}"
%format Symb = "\D{Symb}" 
%format NT = "\Con{NT}"
%format Tm = "\Con{Tm}"
%format HSet = "\D{HSet}"
%format Type = "\D{Type}"
%format constructor = "\mathkw{constructor}"
%format nullable = "\F{nullable}"
%format headSet = "\F{headSet}"
%format mkType = "\F{mk}"

In this section, we describe an Agda implementation of PEGs using
our type system to formalize well-formed PEGs using an intrinsically typed approach.

\subsection{PEG Typed Syntax}

\paragraph{Type syntax} First, we discuss how we represent variables
and terminal symbols of the PEG. In dependently-typed programming languages, like Agda,
is standard to represent variable bindings using De Bruijn indexes represented by
type |Fin|~\cite{DEBRUIJN72}. We denote a head-set for a parsing expression as a list
of |Fin| values.
\begin{spec}
HSet : Set
HSet = List (Fin n)
\end{spec}

Using the definition of |HSet|, we can specify our type syntax as
record containing a boolean, which holds when the expression succeeds
without any symbol and the head set of a parsing expression.

\begin{spec}
record Type : Set where
  constructor mkType
  field
    nullable : Bool
    headSet  : HSet
\end{spec}
%format _=>_ = "\F{\_\Rightarrow\_}"
%format => = "\F{\Rightarrow}"
%format _:*:_ = "\F{\_\otimes\_}"
%format :*: = "\F{\otimes}"
%format _:+:_ = "\F{\_\oplus\_}"
%format :+: = "\F{\oplus}"
%format && = "\F{\land}"
%format || = "\F{\lor}"
Our operations on types are just Agda implementations of the previously
defined notations. The unique difference is that we use list concatenation
to represent the union of two first sets.
\begin{spec}
_=>_ : Bool -> HSet -> HSet
true => fs = fs
false => _ = []

_:*:_ : Type -> Type -> Type
(mkType b fs) :*: (mkType b' fs') = mkType (b && b') (fs ++ b => fs')

_:+:_ : Type -> Type -> Type
(mkType b fs) :+: (mkType b' fs') = mkType (b || b') (fs ++ fs')
\end{spec}
%format neg = "\D{\neg}"
%format In = "\D{\in}"
\paragraph{Parsing expression syntax} Our syntax definition for
parsing expressions is an Agda encoding of the typing judgment
of Figure~\ref{fig:typesystem}. Encoding the type system judgment
as an Agda inductive type requires the definition of a typing context.
Since we represent variables as De Bruijn indexes (using the finite type,
|Fin|) it is natural to implement contexts as length-indexed lists of types.
%format Ctx = "\D{Ctx}"
\begin{spec}
Ctx : Set
Ctx = Vec Type n
\end{spec}
Using the context definition, we define a type to denote the fact
that a variable should not be in its expression head set. In this
type definition we use Agda's standard library list membership
predicate, |In|, and the negation operator, |neg|.
%format validVar = "\F{validVar}"
\begin{spec}
validVar : Ctx -> Fin n -> Set
validVar sig v = neg (v In (headSet (lookup sig v)))
\end{spec}

%format PExp = "\D{PExp}"
%format eps = "\Con{\epsilon}"
%format #_   = "\Con{\#\_}"
%format var = "\Con{var}"
%format ** = "\Con{\bullet}"
%format / = "\Con{/}"
%format _* = "\Con{\_\star}"
%format ! = "\Con{!}"
%format * = "\Con{\star}"
The type |PExp| define the intrinsically typed syntax of
parsing expressions.
\begin{spec}
data PExp (sig : Ctx) : Type -> Set where
  eps   : PExp sig (mkType true [])
  #_  : (c : Char) -> PExp sig (mkType false [])
  var : forall v -> validVar sig v -> PExp sig (lookup sig v)
  _ ** _ : PExp sig t -> PExp sig t' -> PExp sig (t :*: t')
  _ / _ : PExp sig t -> PExp sig t' -> PExp sig (t :+: t')
  _*  : PExp sig (mkType false fs) -> PExp sig (mkType true fs)
  ! _  : PExp sig (mkType b fs) -> PExp sig (mkType true fs)
\end{spec}

Each constructor of |PExp| is equivalent to a type system rule in
Figure~\ref{fig:typesystem} and its meaning is immediate.
%format PEGs = "\D{PExps}"
%format mkPEGs = "\Con{mkPExps}"
%format AllV = "\D{All}"
%format exprs = "\F{exprs}"

Since we represent variables as De Bruijn indexes, we need to relate
an expression with its type on typing context |Ctx|.
Datatype |PEGs| stores the set of rules (parsing expressions) of a PEG. 
We use type |AllV| to enforce the relation between an expression and
its type on context. 
\begin{spec}
record PEGs (sig : Ctx) : Set where
  constructor mkPEGs
  field exprs : AllV (\ t -> PExp sig t) sig
\end{spec}
%format Grammar = "\D{PEG}"
%format mkGrammar = "\Con{mkPEG}"
%format sigs = "\F{sigs}"
%format start = "\F{start}"
%format pegs = "\F{pexps}"
Finally, we represent a PEG as a record containing the typing context for
its variables, a value which indicating its initial parsing expression and a value
of type |PEGs|, which stores all rules for the PEG.
\begin{spec}
record Grammar : Set where
  constructor mkGrammar
  field
    sigs : Ctx
    start : Fin n
    pegs  : PEGs sigs
\end{spec}
\begin{Example}
  Let's consider again the expression $a(!b/c)^*$. Trying to construct such expression
  using type |PExp| will result in a type error. Notice that $(!b/c)$ expression can
  be denoted as the following |PExp| value:
\begin{spec}
  e :: PExp [] (mkType true [])
  e = (! (# 'b')) / (# 'c')
\end{spec}
However, star operator type is
\begin{spec}
PExp sig (mkType false fs) -> PExp sig (mkType true fs)
\end{spec}
which avoids the application |e *| being well-typed.
\end{Example}

\subsection{An Interpreter for Typed PEGs}

An important restriction on
almost type theory based proof assistant is that
they only allow the definition of total functions, i.e., every function
must terminate in a finite number of steps and should be defined to every
value in its domain. A simple technique to ensure termination of complex
recursive functions is the usage of ``fuel'', a natural number
parameter to limit the number of allowed recursive calls~\cite{McBride15}.
In order to convince Agda's termination checker, we use a fuel parameter
that is decreased at each recursive call. Aiming to prove the equivalence
of our interpreter with PEGs semantics, we introduce a semantics which
uses an additional parameter to control the number of maximum recursive
steps allowed in parsing. Such semantics can be understood as a relational specification
of our PEG interpreter and we name such semantics as \emph{fuel based semantics},
and it is specified as a judgment $(e,s)\Rightarrow^n_G r$,
which means that expression $e$ parses the input string $s$ in, at most,
$n$ recursive steps producing a result $r$ (Figure~\ref{fig:fuelpegsemantics}).

Fuel-based semantics has a very similar definition to the standard
semantics for PEGs. The key differences are: 1) at each recursive step,
we decrease the fuel counter; and 2) we add a rule that fails the parsing of
a pair $(e,s)$ whenever the fuel value reaches zero.
\begin{figure*}
   \[
      \begin{array}{cccc}
         \multicolumn{4}{c}{\infer[_{\{Out\}}]{(e,s) \Rightarrow^0_G \bot}{}}\\
         \infer[_{\{Eps\}}]{(\epsilon,s)\Rightarrow^{n+1}_G (\epsilon,s)}{} &
         \infer[_{\{ChrS\}}]{(a,as_r) \Rightarrow^{n+1}_G (a,s_r)}{}  &
         \infer[_{\{ChrF\}}]{(a,bs_r) \Rightarrow^{n+1}_G \bot}{a \neq b} &
         \infer[_{\{Var\}}]{(A,s) \Rightarrow^{n+1}_G r}
                           {A \leftarrow e \in R & (e,s) \Rightarrow^{n}_G r} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{S1}\}}]{(e_1\,e_2,s_{p1}s_{p2}s_r) \Rightarrow^{n+1}_G (s_{p1}s_{p2}, s_r)}
                                 {(e_1,s_{p1}s_{p2}s_r) \Rightarrow^n_G (s_{p1},s_{p2}s_r) &
                                 (e_2,s_{p2}s_r)\Rightarrow^n_G (s_{p2},s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Cat_{F2}\}}]{(e_1\,e_2,s_ps_r) \Rightarrow^{n+1}_G \bot}
                                 { (e_1,s_ps_r) \Rightarrow^n_G (s_p,s_r) &
                                    (e_2,s_r) \Rightarrow^n_G \bot}} \\ \\
         \infer[_{\{Cat_{F1}\}}]{(e_1\,e_2,s)\Rightarrow^{n+1}_G \bot}{(e_1,s) \Rightarrow^n_G \bot} &
         \infer[_{\{Alt_{S1}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Rightarrow^{n+1}_G (s_p,s_r)}
                                {(e_1,s_p\,s_r)\Rightarrow^n_G (s_p,s_r)} &
         \multicolumn{2}{c}{
            \infer[_{\{Alt_{S2}\}}]{(e_1\,/\,e_2,s_p\,s_r) \Rightarrow^{n+1}_G r}
                                  {(e_1,s_p\,s_r)\Rightarrow^n_G \bot &
                                   (e_2,s_p\,s_r)\Rightarrow^n_G r}
         } \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Star_{rec}\}}]{(e^\star,s_{p1}s_{p2}s_r) \Rightarrow^{n+1}_G (s_{p1}s_{p2},s_r)}
                                 {(e,s_{p1}s_{p2}s_r) \Rightarrow^n_G (s_{p1},s_{p2}s_r) &
                                  (e^\star, s_{p2}s_r) \Rightarrow^n_G (s_{p2},s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Star_{end}\}}]{(e^\star,s) \Rightarrow^{n+1}_G (\epsilon,s)}
                                    {(e,s) \Rightarrow^n_G \bot}} \\ \\
         \multicolumn{2}{c}{
            \infer[_{\{Not_F\}}]{(!\,e,s_p\,s_r) \Rightarrow^{n+1}_G \bot}
                               {(e,s_p\,s_r) \Rightarrow^n_G (s_p,s_r)}
         } &
         \multicolumn{2}{c}{
            \infer[_{\{Not_S\}}]{(!\,e,s) \Rightarrow^{n+1}_G (\epsilon,s)}
                               {(e,s) \Rightarrow^n_G \bot}
         }
      \end{array}
   \]
   \centering
   \caption{Fuel-based parsing expression operational semantics.}
   \label{fig:fuelpegsemantics}
\end{figure*}
%The next theorems shows the equivalence between these two semantics.
%\begin{Theorem}\label{thm:fuel-standard}
%  If $(s,e) \Rightarrow^n_G (s_p,s_r)$ then $(s,e)\Rightarrow_G (s_p,s_r)$.
%\end{Theorem}
%\begin{proof}
%  Induction on the derivation of $(s,e)\Rightarrow^n_G (s_p,s_r)$.
%\end{proof}
%\begin{Theorem}
%  If $(s,e)\Rightarrow_G r$ then exists $n \in \mathbb{N}$, s.t.
%  $(s,e)\Rightarrow^n_G r$.
%\end{Theorem}
%\begin{proof}
%  Induction on the derivation of $(s,e)\Rightarrow_G r$.
%\end{proof}
%format Parse = "\D{Parse}"
%format Ok = "\Con{Ok}"
%format Error = "\Con{Error}"
%format OutOfGas = "\Con{OutOfGas}"
Before defining our interpreter, we need a type to represent its results.
Type |Parse| describes the possible outcomes of an execution of the interpreter.
\begin{spec}
data Parse : List Char -> Set where
  Ok       : forall {s} pre suf -> s == (pre ++ suf) -> Parse s
  Error    : forall (s : List Char) -> Parse s
  OutOfGas : forall (s : List Char) -> Parse s
\end{spec}
Constructor |Ok| takes two strings as parameters, the first denotes the parsed
prefix, the second the remaining suffix of the input string and a proof that
shows that input string is the concatenation of the parsed prefix and the
suffix. Constructors
|Error| and |OutOfGas| represent a parsing error result or that fuel provided
was not sufficient to finish, respectively.
%format parseExp = "\F{parseExp}"
%format Fuel = "\D{Fuel}"
%format # = "\Con{\#}"
%format =?= = "\F{\overset{?}{\equiv}}"
%format ctx = "\V{sigs}"

The main interpreter function, |parseExp|, is defined by recursion on its fuel
counter and on the structure of parsing expressions syntax. The first equation
shows that when the fuel reaches |zero|, we return an |OutOfGas| error. 
\begin{spec}
parseExp : Fuel -> PExp ctx t -> (s : List Char) -> Parse s
parseExp zero e s = OutOfGas s
\end{spec}
For |eps| we return a successful parse which contains an empty string as
its parsed prefix and the input as the remaining suffix.
\begin{spec}
parseExp (succ n') eps s = Ok [] s refl
\end{spec}
Parsing a single alphabet symbol parsing expression will result in a parsing
error whenever the input is an empty string or its leading character is a different
one. When the first input symbol matches the expression character, then we return the
symbol as a parsed prefix and rest of the string as its remaining suffix.
Function |=?=| returns a proof of (in)equality of two input characters.
\begin{spec}
parseExp (succ n') (# c) [] = Error []
parseExp (succ n') (# c) (c' :: s') with c =?= c'
...| yes eq = Ok [ c ] s' refl 
...| no neq = Error (c' :: s')
\end{spec}
In order to parse a variable, we need to retrieve its corresponding expression in
the grammar. Note that we need to use record projections to get the list of expressions
of grammar |G| and then use function |lookup| to obtain the expression of a variable
|v : Fin n|, as expressed in the equation below.
\begin{spec}
parseExp (succ n') (var v x) s
   = parseExp n' (lookup v (exprs (pegs G))) s
\end{spec}
%format ++-assoc = "\F{++-assoc}"
The parsing of the sequence of two expressions threads the remaining suffix of the first
expression as the input of second. When one of the expressions fails, the whole sequence
also fails. Notice that on the success case, we need to use a lemma that shows that list
concatenation is an associative operation (|++-assoc|).
\begin{spec}
parseExp (succ n') (e ∙ e') s with parseExp n' e s
... | Ok pre suf refl with parseExp n' e suf
... | Ok pre suf refl  | Ok pre' suf' refl
     = Ok (pre ++ pre') suf' (++-assoc pre pre' suf')
-- some code omitted.
\end{spec}
The prioritized choice of two expression always try to parse the input using the left option.
We only try the right expression of a choice when the left-one fails.
\begin{spec}
parseExp (succ n') (e / e') s with parseExp n' e s
... | Ok pre suf refl = Ok pre suf refl
... | Error _ with parseExp n' e' s
... | Error _ | Ok pre suf refl = Ok pre suf refl
-- some code omitted.
\end{spec}
The result of parsing the input using the star operator is, basically, parse the input with
the expression $e$ and then parse the remaining using the expression $e^*$. It is important to
notice that the only way that parsing a star expression fails is because it has not enough
fuel to conclude. When we have a parsing error, we return the parsed prefix
(when the parse of $e$ succeeds) or the empty string.
\begin{spec}
parseExp (succ n') (e *) s with parseExp n' e s
... | Ok pre suf refl with parseExp n' (e *) suf
... | Ok pre suf refl | Ok pre' suf' refl
  = Ok (pre ++ pre') suf' (++-assoc pre pre' suf')
... | Ok pre suf refl | Error = Ok pre suf refl 
... | Error _ = Ok [] s
-- some code omitted.
\end{spec}
We finish the definition of function |parseExp| with the equations for the not operator.
The equations for |! e| shows that it succeeds by returning an empty string parsed prefix
when the parsing of |e| fails by a parsing error. This PEG operator fails whenever the
parsing of |e| succeeds.
\begin{spec}
parseExp (succ n') (! e) s with parseExp n' e s
parseExp (succ n') (! e) s | Ok _ _ _ = Error s
parseExp (succ n') (! e) s | Error _ = Ok [] s refl
parseExp (succ n') (! e) s | OutOfGas _ = OutOfGas s
\end{spec}
%format parse = "\F{parse}"
Using the |parseExp| function, we define the PEG interpreter top level function, |parse|, which
call it using the starting expression of grammar |G|.
\begin{spec}
parse : Fuel -> (s : List Char) -> Parse s
parse n s = parseExp n (lookup (start G) (exprs (pegs G))) s
\end{spec}

The correctness of our |parseExp| function is expressed by the following theorem, which
can be proved by induction on the complexity of the pair $(n,e)$.

\begin{Theorem}
  If |parseExp n e s = Ok pre suf refl| then we have that $(e,s)\Rightarrow^n_G (pre,suf)$ holds.
\end{Theorem}


\section{Discussion}\label{sec:discussion}

While our type system provides a simple approach which implies completeness of well-typed PEGs,
our current Agda formalization has a problem: it uses fuel to guarantee termination.  Ideally, we
should be able to execute parsing expressions by structural recursion on its typing derivation.
While this is certainly possible, our current solution has two issues that avoid it.

The first issue happens because Agda's compiler cannot deduce that input string size decreases when we execute
the second component of a sequence expression and the next iteration
of the star operator on the remaining suffix of the input. This issue is solvable by using |Vec|
instead of lists to represent input strings, since type |Vec| stores information about its size.
We avoid using |Vec| to provide a clear presentation
by simply using fuel to convince Agda's termination checker.

The second problem is with how we deal with variables: we simply execute its expression stored
in grammar. While this is the interpreter expected behavior, it does not allow an easy way
to convince Agda's compiler that such equation still make the interpreter a total function.

We leave the task of producing a intrinsically representation which
allows a direct recursive definition of our interpreter to future work.

\section{Related Work}\label{sec:related}

A formalization of an interpreter for PEGs, using Coq, was the subject of
Koprowski's work~\cite{Kropowski11} that extends parsing expressions with
the notion of semantic value. Such values can be understood as the resulting
parse tree for a given expression, which are equivalent to parse trees
used in the context of regular expression parsing~\cite{Nielsen2011}.
Termination of PEGs are proved by Kropowski using the Coq encoding of
Ford's well-formedness predicate by a fixpoint computation on the grammar
expression set. In order to convince Coq's termination checker, authors have to
define a ordering sub-expression relation between parsing expressions and build
interpreter by recursion on the ordering of pairs $(e,s)$ of a well-formed
expression $e$ and a string $s$. Unlike Kropowski's work, our current
termination argument relies on the usage of fuel, since currently we did not
manage to ensure parsing termination for the variable\footnote{Cases for concatenation and
star operator do not pass Agda's totality checker. However, it can be solved by using
type |Vec| instead of |List| to represent parsing input.} case in our intrinsically
typed enconding of PEGs.

The relation between context-free grammars (CFGs) and PEGs was studied by
Mascarenhas et. al.~\cite{MASCARENHAS14}. The authors present a recognition-based
semantics for CFGs that is used to highlight that the main difference between
CFGs and PEGs is the choice operator which is non-deterministic in CFGs.
The work of Mascarenhas et. al. also formalizes the relation of PEGs and
some classes of top-down grammars like LL(1), strong-LL(k) and LL-regular
languages. While providing a careful formalization of the semantics for CFGs and
equivalence results of PEGs and classes of CFGs, the authors do not provide
any mechanized formalization of their results, like our work.

A computational interpretation of context-free expressions is given by~\cite{Sulzmann17}.
The article extend results on interpreting regular expression parsing as a type inhabitation
problem to context-free languages~\cite{Nielsen2011}. Authors then formalize type coercions
between context-free and regular expressions which can be understood as a predictive parser
for the language associated with the context-free expression. The formulation of coercions
uses derivatives~\cite{Brzozowski1964}. Detailed informal proofs are presented in an appendix.
Our current work is only concerned with a type system which ensures the termination of PEGs.
We leave the problem of producing parsing evidence to future work.

 Firsov et al.~describe a
certified algorithm for RE parsing by converting an input RE to an
equivalent NFA represented as a boolean matrix~\cite{FirsovU13}. A
matrix library based on some ``block'' operations~\cite{MacedoO13} is
developed and used Agda formalization of NFA-based parsing
~\cite{Norell2009}. Compared to our work, a NFA-based formalization requires
much more infrastructure (such as a Matrix library).

Firsov describes an Agda formalization of a parsing algorithm that
deals with any CFG (CYK algorithm)~\cite{Firsov2014}. Bernardy
et al.~describe a formalization of another CFG parsing algorithm in
Agda~\cite{BernardyJ16}: Valiant's algorithm~\cite{Valiant1975}, which
reduces a CFG parsing problem to boolean matrix multiplication. 

%A certified LR(1) CFG validator is described
%in~\cite{Jourdan2012}. The formalized checking procedure verifies if
%a CFG and an automaton match. They proved soundness and completeness of
%the validator in the Coq proof
%assistant~\cite{Bertot2010}. Termination of the LR(1) automaton
%interpreter is ensured by imposing a natural number bound on
%allowed recursive calls.

%Formalization of a parser combinator library was the subject of
%Danielsson's work~\cite{Danielsson2010}. He built a library of parser
%combinators using coinduction and provide correctness proofs of such
%combinators.

The problem of dealing with left-recursion on PEGs was studied by~\cite{Warth2008,MEDEIROS14}.
Warth et. al. propose a modification of the memoization mechanism of
packrat parsing to support direct and indirect left-recursion ~\cite{Warth2008}.
They use the packrat memoization table to detect left-recursion, and then begins an
iterative process. At each iteration, a recursion step is performed and its
results are memoized in the packrat table for its use in the next iteration.
Medeiros et. al. extend the PEG semantics to give a meaningful to left-recursion
by limiting the number of left-recursion a nonterminal may have~\cite{MEDEIROS14}.
Similar to Warth et. al. approach, Medeiros et. al. idea relies on limiting the
number of left-recursive calls to zero, which always fails
, and increase the number of
left-recursion that, on each step, uses the previous results.
It is done until a smaller prefix of the input string is consumed.  
A difference between Medeiros et. al. and Warth et. al.'s approach is that the latter’s
algorithm is tightly coupled to the packrat parsing whereas Medeiros et. al. formalization is
not dependent of a particular implementation. In our approach, PEGs with
left-recursive rules are untyped,
being simply rejected.


\section{Conclusion}\label{sec:conclusion}

In this work, we present a type system that can be used as an alternative to
PEGs well-formedness. We show that our type system is equivalent to
Ford's well-formedness predicate and develop an intrinsically typed interpreter
for PEGs using Agda programming language.

As future work, we intend to improve our intrinsically typed syntax in order to allow
a structural recursive interpreter that do not use fuel and produce, as result,
parse trees. We also would like to investigate if is possible to interpret PEG parsing as
a type inhabitation problem like regular and context-free expression parsing.

\begin{acks}
This work is supported by the \grantsponsor{CNPq}{CNPq -- Brazil}{} under grant No.: \grantnum{CNPq}{426232/2016}.
\end{acks}


% \section*{References}
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}

\end{document}
